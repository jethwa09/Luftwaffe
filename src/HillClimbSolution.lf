target C {
    platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
    },
    single-threaded: true
  }
  
import Line from "lib/Line.lf"
import Display from "lib/Display.lf"
import Gyro from "lib/IMU.lf"
import Accelerometer from "lib/IMU.lf"
import Encoders from "lib/Encoders.lf"
// import Motors from "lib/Motors.lf"
import MotorsWithFeedback from "lib/MotorsWithFeedback.lf"

reactor Robot {
    input drive: bool
    input encoder_left: int
    input encoder_right: int
    input gyro_z: float
    input line_sensed: int
    input pitch: float
    input roll: float
    output notify: string
    output left_speed: float
    output right_speed: float
    state step: int = 0
    state target_angle: float = 30.0
    state current_angle: float = 0.0
    state initial_left: int = 0
    state initial_right: int = 0
    state recovery_side: int = 0 // 0 - line sensed from the left, 1 - line sensed from the right
    state position: int = 0 // 0 - climbing, 1 - flat, 2 - descend
    state slope_flag: int = 0
    state start_flag: int = 0
    state check_pitch: int = 0

    logical action reverse
    logical action straighten
    logical action start_turn
    logical action resume_drive
    logical action check_for_pitch

    preamble {=
        #include <math.h>
        #ifndef M_PI
        #define M_PI 3.14159265358979323846
        #endif
        #ifndef WHEEL_DIAMETER
        const float WHEEL_DIAMETER = 3.175; // cm
        #endif
        #ifndef WHEEL_CIRCUMFERENCE
        const float WHEEL_CIRCUMFERENCE = M_PI * WHEEL_DIAMETER;
        #endif
        #ifndef TICKS_PER_REVOLUTION
        const int TICKS_PER_REVOLUTION = 360;
        #endif
        #ifndef FORWARD_SPEED
        const float FORWARD_SPEED = 0.15f;
        #endif
        #ifndef TURN_SPEED_STRONG
        const float TURN_SPEED_STRONG = 0.2f;
        #endif
        #ifndef TURN_SPEED_WEAK
        const float TURN_SPEED_WEAK = 0.1f;
        #endif
        #ifndef REVERSE_SPEED
        const float REVERSE_SPEED = 0.1f;
        #endif
    =}

    reaction(startup) -> notify {=
        lf_set(notify, "INIT");
    =}

    reaction(check_for_pitch) {=
        self->check_pitch = 1;
    =}

    initial mode STOPPED {
        reaction(drive) -> reset(DRIVING), check_for_pitch, notify, left_speed, right_speed {=
            if (drive->value) {
                lf_set(left_speed, FORWARD_SPEED);
                lf_set(right_speed, FORWARD_SPEED);
                lf_set_mode(DRIVING);
                lf_set(notify, "DRIVING");
                lf_schedule(check_for_pitch, SEC(3));
            }
        =}
    }

    mode DRIVING {
        reaction(line_sensed) -> reset(REVERSING), notify, left_speed, right_speed, reverse {=
            if (line_sensed->value) {
                switch (line_sensed->value) {
                    case 1: // Line sensed on the left
                        self->recovery_side = 1;
                        self->target_angle = 30.0;
                        lf_set(notify, "LEFT");
                        break;
                    case 2: // Line sensed in the center, cliff sensed 
                        lf_set(notify, "CLIFF");
                        self-> recovery_side = 3;
                        self->target_angle = 150.0;
                        break;
                    case 3: // Line sensed on the right
                        lf_set(notify, "RIGHT");
                        self->recovery_side = 2;
                        self->target_angle = 30.0;
                        break;
                }
                lf_set(left_speed, 0.0f);
                lf_set(right_speed, 0.0f);
                self->initial_left = self->_lf_encoder_left->value;
                self->initial_right = self->_lf_encoder_right->value;
                lf_set(notify, "REVERSING");
                lf_set_mode(REVERSING);
                lf_schedule(reverse, 0);
            }
        =}

        reaction(encoder_left, encoder_right) -> left_speed, right_speed {=
            lf_set(left_speed, FORWARD_SPEED);
            lf_set(right_speed, FORWARD_SPEED);
        =}

        reaction(drive) -> reset(STOPPED), notify, left_speed, right_speed {=
            if (!drive->value) {
                lf_set(notify, "STOPPED");
                lf_set(left_speed, 0.0f);
                lf_set(right_speed, 0.0f);
                lf_set_mode(STOPPED);
            }
        =}

        reaction(pitch) -> reset(REVERSING), start_turn {=
            if ((pitch->value <= 1.0) && (self->slope_flag == 0) && (self->check_pitch == 1)) {
                lf_schedule(start_turn, MSEC(200));
                lf_set_mode(REVERSING);
                self->slope_flag = 1;
                self->target_angle = 150.0;
                self->recovery_side = 3;
            } 
        =}

        reaction(roll) -> start_turn, reset(RECOVERY) {=
            if ((roll->value < -4.0) && (self->start_flag == 0)) {
                lf_schedule(start_turn, 0);
                self->recovery_side = 1;
                self->start_flag = 1;
                lf_set_mode(RECOVERY);
            } else if ((roll->value > 4.0) && (self->start_flag == 0)) {
                lf_schedule(start_turn, 0);
                self->recovery_side = 2;
                self->start_flag = 1;
                lf_set_mode(RECOVERY);
            }
        =}
    }

    mode REVERSING {
        reaction(reverse) -> notify, left_speed, right_speed, start_turn {=
            lf_set(notify, "BACKING");
            lf_set(left_speed, -REVERSE_SPEED);
            lf_set(right_speed, -REVERSE_SPEED);
            // lf_schedule(start_turn, MSEC(1500));
        =}

        reaction(encoder_left, encoder_right) -> notify, left_speed, right_speed, start_turn {=
            int left_ticks = encoder_left->value - self->initial_left;
            int right_ticks = encoder_right->value - self->initial_right;
    
            float left_distance = (left_ticks * WHEEL_CIRCUMFERENCE) / TICKS_PER_REVOLUTION;
            float right_distance = (right_ticks * WHEEL_CIRCUMFERENCE) / TICKS_PER_REVOLUTION;
            float average_distance = (left_distance + right_distance) / 2.0;

            // Convert the float to a string with one decimal place
            if (fabs(average_distance <= -7.0)) {
                lf_set(notify, "STARTING TURN");
                lf_schedule(start_turn, MSEC(200));
            } else {
                lf_set(left_speed, -REVERSE_SPEED);
                lf_set(right_speed, -REVERSE_SPEED);
            }
        =}

        reaction(start_turn) -> left_speed, right_speed, start_turn, reset(RECOVERY), notify {=
            lf_set(notify, "STARTING TURN");
            lf_set(left_speed, 0.0f);
            lf_set(right_speed, 0.0f);
            lf_set_mode(RECOVERY);
            lf_schedule(start_turn, 0);
        =}
    }

    mode RECOVERY {
        reaction(start_turn) -> left_speed, right_speed, notify {=
            lf_set(notify, "TURNING");
            if (self->recovery_side) {
                switch (self->recovery_side) {
                    case 1: // correct away from the left side
                        lf_set(left_speed, TURN_SPEED_STRONG);
                        lf_set(right_speed, TURN_SPEED_WEAK);
                        break;
                    case 2: // correct away from the right side
                        lf_set(left_speed, TURN_SPEED_WEAK);
                        lf_set(right_speed, TURN_SPEED_STRONG);
                        break;
                    case 3: // Begin 180 degree turn
                        lf_set(left_speed, TURN_SPEED_STRONG);
                        lf_set(right_speed, -TURN_SPEED_STRONG);
                        break;
                }
            }
        =}

        reaction(gyro_z) -> notify, left_speed, right_speed, straighten, reset(DRIVING) {=
            self->current_angle += self->_lf_gyro_z->value * 0.05;
            printf("Current Angle: %f", self->current_angle);

            if (fabs(self->current_angle) >= self->target_angle){
                self->current_angle = 0.0;
                lf_set(left_speed, 0.0f);
                lf_set(right_speed, 0.0f);
                lf_set(notify, "DRIVING");
                lf_set_mode(DRIVING);
            } else {
                switch (self->recovery_side) {
                    case 1: // correct away from the left side
                        lf_set(left_speed, TURN_SPEED_STRONG);
                        lf_set(right_speed, TURN_SPEED_WEAK);
                        break;
                    case 2: // correct away from the right side
                        lf_set(left_speed, TURN_SPEED_WEAK);
                        lf_set(right_speed, TURN_SPEED_STRONG);
                        break;
                    case 3: // 180 degree turn
                        lf_set(left_speed, TURN_SPEED_STRONG);
                        lf_set(right_speed, -TURN_SPEED_STRONG);
                        break;
                }
            }
        =}
    }

    mode STRAIGHTEN {
        reaction(straighten) -> left_speed, right_speed, resume_drive, reset(DRIVING) {=
            switch (self->recovery_side) {
                case 1: // Left correction requires straightening out to the right
                    lf_set(left_speed, TURN_SPEED_WEAK);
                    lf_set(right_speed, TURN_SPEED_STRONG);
                    break;
                case 2: // Right correction requires straightening out to the left
                    lf_set(left_speed, TURN_SPEED_STRONG);
                    lf_set(right_speed, TURN_SPEED_WEAK);
                    break;
            }
            lf_schedule(resume_drive, MSEC(1000));
            self->recovery_side = 0;
        =}

        reaction(resume_drive) -> left_speed, right_speed, reset(DRIVING) {=
            lf_set(left_speed, FORWARD_SPEED);
            lf_set(right_speed, FORWARD_SPEED);
            lf_set_mode(DRIVING);
        =}
    }
}


main reactor {
    disp = new Display()
    gyro = new Gyro()
    encoder = new Encoders()
    robot = new Robot()
    motors = new MotorsWithFeedback()
    line = new Line()
    accel = new Accelerometer()
    // accel = new Accelerometer
    logical action clear

    timer t(0, 50 ms)
    state drive: bool = false
    timer seconds(0, 1 s)  // Timer used to display seconds.
    timer end_calibration(10 s)
    state count: int = 0

    robot.left_speed -> motors.left_speed
    robot.right_speed -> motors.right_speed
    encoder.left -> motors.left
    encoder.right -> motors.right

    preamble {=
        float sensor_threshold = 900;
        bool check_sensor(float sensor_val) {
            if (sensor_val > sensor_threshold) {
                return true;
            } else {
                return false;
            }
        }

        float calculate_tilt(float a1, float a2, float a3) {
            return (atan(a1 / sqrt(a2*a2 + a3*a3)) * 180) / M_PI; // for calculating pitch
        }
    =}

    reaction(startup) -> disp.line0, disp.line1, disp.line2 {=
        lf_set(disp.line0, "CALIBRATING");
        lf_set(disp.line1, "Roll robot over");
        lf_set(disp.line2, "light and dark.");
    =}

    reaction(seconds) -> disp.line3 {=
        static char buf[17];
        snprintf(buf, 17, "time:%8d s", self->count++);
        lf_set(disp.line3, buf);
    =}

    reaction(end_calibration) -> line.calibrate {=
        lf_set(line.calibrate, false);
        self->drive = true;
    =}

    reaction(t) -> robot.drive, gyro.trigger, encoder.trigger, line.trigger, accel.trigger {=
        lf_set(robot.drive, self->drive);
        lf_set(gyro.trigger, true);
        lf_set(encoder.trigger, true);
        lf_set(line.trigger, true);
        lf_set(accel.trigger, true);
    =}

    reaction(encoder.left) -> robot.encoder_left {=
        lf_set(robot.encoder_left, encoder.left->value);
    =}

    reaction(encoder.right) -> robot.encoder_right {=
        lf_set(robot.encoder_right, encoder.right->value);
    =}

    reaction(gyro.z) -> robot.gyro_z {=
        lf_set(robot.gyro_z, gyro.z->value);
    =}

    reaction(accel.x, accel.y, accel.z) -> robot.pitch, robot.roll, disp.line3 {=
        float pitch = calculate_tilt(accel.x->value, accel.y->value, accel.z->value);
        float roll = calculate_tilt(accel.y->value, accel.x->value, accel.z->value);
        lf_set(robot.pitch, pitch);
        lf_set(robot.roll, roll);
        static char buf[33];
        snprintf(buf, 33, "roll%.1f", roll);
        lf_set(disp.line3, buf);
    =}

    reaction(line.reflect) ->  robot.line_sensed, disp.line1 {=
        if (check_sensor(line.reflect->value[0])) {
            lf_set(robot.line_sensed, 1); // left sensor sensed
        } else if(check_sensor(line.reflect->value[4])) {
            lf_set(robot.line_sensed, 3); // right sensor sensed
        } else if (check_sensor(line.reflect->value[1]) || check_sensor(line.reflect->value[2]) || check_sensor(line.reflect->value[3])) {
            lf_set(robot.line_sensed, 2); // center sensor sensed
        }
    =}

    reaction(robot.notify) -> disp.line0 {=
        lf_set(disp.line0, robot.notify->value);
    =}

    reaction(encoder.left, encoder.right) -> disp.line2 {=
        static char buf[33];
        const float wheel_diameter = 3.175; // cm
        const float wheel_circumference = M_PI * wheel_diameter;
        const int ticks_per_revolution = 360; // Assuming 360 ticks per revolution
        int left_ticks = encoder.left->value;
        int right_ticks = encoder.right->value;

        float left_distance = (left_ticks * wheel_circumference) / ticks_per_revolution;
        float right_distance = (right_ticks * wheel_circumference) / ticks_per_revolution;
        float average_distance = (left_distance + right_distance) / 2.0;

        snprintf(buf, 33, "L%d R%d D%.2f", left_ticks, right_ticks, average_distance);
        lf_set(disp.line2, buf);
    =}

    // reaction(gyro.x, gyro.y, gyro.z) -> disp.line3 {=
    //     static char buf[33];
    //     snprintf(buf, 33, "x%.1f y%.1f z%.1f", gyro.x->value, gyro.y->value, gyro.z->value);
    //     lf_set(disp.line3, buf);
    // =}

    reaction(clear) -> disp.line1 {=
        lf_set(disp.line1, "");
    =}
}

