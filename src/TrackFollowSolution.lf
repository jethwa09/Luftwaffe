target C {
    platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
    },
    single-threaded: true
}

import Line from "lib/Line.lf"
import Display from "lib/Display.lf"
import Encoders from "lib/Encoders.lf"
import MotorsWithFeedback from "lib/MotorsWithFeedback.lf"
import Motors from "lib/Motors.lf"

reactor Robot {
    input drive: bool
    input encoder_left: int
    input encoder_right: int
    input left_desired: float
    input right_desired: float

    state current_left: float
    state current_right: float

    output left_speed: float
    output right_speed: float
    output notify: string

    state turn_side: int

    timer printer(0, 3 s)

    reaction(startup) -> notify {=
        lf_set(notify, "INIT");
    =}

    initial mode STOPPED {
        reaction(drive) -> notify, right_speed, left_speed, reset(DRIVING){=
            if (drive->value) {
                lf_set(notify, "DRIVING");
                lf_set_mode(DRIVING);
            }
        =}
    }

    mode DRIVING {
        reaction(left_desired, right_desired)-> notify, left_speed, right_speed {=
            lf_set(notify, "ADJUSTING");
            self->current_left = left_desired->value;
            self->current_right = right_desired->value;
            lf_set(left_speed, self->current_left);
            lf_set(right_speed, self->current_right);
        =}

        reaction(printer) {=
            printf("Current Left %f\n", self->current_left);
            printf("Current Right %f\n", self->current_right);
        =}

        reaction(drive) -> reset(STOPPED) {=
            if (!drive->value) {
                lf_set_mode(STOPPED);
            }
        =}


        reaction(encoder_left, encoder_right) -> notify, left_speed, right_speed {=
            lf_set(left_speed, self->current_left);
            lf_set(right_speed, self->current_right);
        =}
    }
}


main reactor(calibration_time: time = 5 s, sample_period: time =  25 ms) {
    line = new Line()
    disp = new Display()
    motors = new MotorsWithFeedback()
    encoder = new Encoders()
    robot = new Robot()

    timer t(0, sample_period)
    timer seconds(0, 1 s)  // Timer used to display seconds.
    timer end_calibration(calibration_time)
    state count: int = 0
    state drive: bool = false
    // Used for PID controller
    state integral: double = 0.0
    state derivative: double = 0.0
    state error: double = 0.0
    state lastError: double = 0.0 // compare to calculated error

    logical action check_if_off

    robot.left_speed -> motors.left_speed
    robot.right_speed -> motors.right_speed
    encoder.left -> motors.left
    encoder.right -> motors.right

    preamble {=
    #include <math.h>
        float FORWARD_SPEED = 0.05f;
        int SETPOINT = 6225; // Desired center point based on the sensor readings
        float KP = 1.2f; // Proportional Gain
        float KI = 0.05f; // Integral gain
        float KD = 0.5f; // derivative gain

        float sensor_threshold = 900;

        bool check_sensor(float sensor_val) {
            if (sensor_val > sensor_threshold) {
                return true;
            } else {
                return false;
            }
        }

        float calculate_center(uint16_t* sensors, int size) {
            int center = 0;
            for (int i = 0; i < size; i++) {
                center += sensors[i] * i;
            }
            return center;
        }
    =}

        reaction(startup) -> disp.line0, disp.line1, disp.line2 {=
            lf_set(disp.line0, "CALIBRATING");
            lf_set(disp.line1, "Roll robot over");
            lf_set(disp.line2, "light and dark.");
        =}

        reaction(seconds) -> disp.line3 {=
            static char buf[17];
            snprintf(buf, 17, "time:%8d s", self->count++);
            lf_set(disp.line3, buf);
        =}

        reaction(end_calibration) -> line.calibrate {=
            lf_set(line.calibrate, false);
            self->drive = true;
        =}

        reaction(t) -> line.trigger, encoder.trigger, robot.drive {=
            lf_set(line.trigger, true);
            lf_set(encoder.trigger, true);
            lf_set(robot.drive, self->drive);
        =}

        reaction(encoder.left) -> robot.encoder_left {=
            lf_set(robot.encoder_left, encoder.left->value);
        =}

        reaction(encoder.right) -> robot.encoder_right {=
            lf_set(robot.encoder_right, encoder.right->value);
        =}

        reaction(line.reflect) -> disp.line2, robot.left_desired, robot.right_desired, check_if_off {=
            if (!check_sensor(line.reflect->value[1]) && check_sensor(line.reflect->value[3])) {
                // printf("Left center white\n");
                self->error = 1;// left center sensor touched white
            } else if (check_sensor(line.reflect->value[1]) && !check_sensor(line.reflect->value[3])) {
                // printf("Right center white\n");
                self->error = -1;// right center sensor touched white
            } else if (check_sensor(line.reflect->value[1]) && check_sensor(line.reflect->value[3])) {
                self->error = 0;
            } else if (!check_sensor(line.reflect->value[0]) && !check_sensor(line.reflect->value[4]) && !check_sensor(line.reflect->value[1]) && !check_sensor(line.reflect->value[3])) {
                lf_schedule(check_if_off, MSEC(2000));
                return;
            } else if (check_sensor(line.reflect->value[0])) {
                self->error = -1;
            } else if (check_sensor(line.reflect->value[4])) {
                self->error = 1;
            }

            double proportional = KP * self->error;
            self->integral += self->error;
            double integral = self->integral * KI;
            double derivative = KD * (self->error - self->lastError);
            self->lastError = self->error;

            double adjust = (proportional + integral + derivative) * 0.01;
            // printf("Adjust %f\n", adjust);
            double left_speed = FORWARD_SPEED + adjust;
            double right_speed = FORWARD_SPEED - adjust;

            if (left_speed < -FORWARD_SPEED) left_speed = -FORWARD_SPEED; // Clamping values
            if (left_speed > FORWARD_SPEED) left_speed = FORWARD_SPEED;
            if (right_speed < -FORWARD_SPEED) right_speed = -FORWARD_SPEED;
            if (right_speed > FORWARD_SPEED) right_speed = FORWARD_SPEED;
                
            lf_set(robot.left_desired, left_speed);
            lf_set(robot.right_desired, right_speed);
            static char buf[17];
            snprintf(buf, 17, "left: %f", left_speed);
            lf_set(disp.line2, buf);
        =}

        reaction(check_if_off)line.reflect -> robot.left_desired, robot.right_desired {=
            if (!check_sensor(line.reflect->value[1]) && !check_sensor(line.reflect->value[3])) { // Checks if the robot is still off the line after a desired time
                lf_set(robot.left_desired, 0.0f);
                lf_set(robot.right_desired, 0.0f);
            }
        =}

        reaction(robot.notify) -> disp.line0 {=
            lf_set(disp.line0, robot.notify->value);
        =}   
}